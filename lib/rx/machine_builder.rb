require 'rx/char_classes'
require 'rx/make_charclasses'

class MachineBuilder

  def MachineBuilder::build(autom, out_dir)
    MachineBuilder.new(autom, out_dir).go
  end
  
  def initialize(autom, out_dir = '.')
    if autom.kind_of? IO
      @autom = autom
    else
      @autom = File.new(autom)
    end
        
    @out_dir = out_dir
    @states = {}
    @state_number = 1
    @fallbacks = {}
    @error_messages = {}
    @transitions = {}
    @class_transitions = {}
    @machine = []
    @action_list = [ '# -Intentionally left blank-' ]
    @funcs = {}
  end

  def go
    @autom.each_line do |l|
      case l
      when /^#/    # comment
      when /^\s*$/ # blank
      when /^State\s+(\S+)\s+(\S+)\s+\{([^}]*)\}\s*$/
        record_state($1, $2, $3)
      when /^T\s+(\S+)\s+(\S+)((\s+!\S+)*)\s*$/
        record_transition($1, $2, $3)
      else
        print "Bogus line #{l}"
      end
    end
    make_tables
  end

  def record_state(name, fallback, error_message)
    @state = name
    @states[name] = @state_number
    @state_number += 1
    @fallbacks[name] = fallback
    @error_messages[name] = error_message
    @transitions[name] = []
    @class_transitions[name] = []
        
  end

  def record_transition(on, to, actions = nil)
    actions = nil unless actions && (actions =~ /\S/)
    @transitions[@state] << [on, to, actions]
  end

  def make_tables

    # '*', 'c' for name char, 's' for name start
    # Values :xml_char, :name_char, :namestart_char
    @char_classes = [ :xml_char ] * @state_number 

    # size the machine
    @machine_size = @state_number * 128
    @machine = [0] * @machine_size
    @actions = [0] * @machine_size

    @states_in_order = @states.keys.sort { |a, b| @states[a] <=> @states[b] }

    @states_in_order.each do |state|

      @transitions[state].each do |transition|
        on, to, actions = transition
        
        # if the to isn't a function - with ()
        if to !~ /^(.*)\((.*)\)/
          # then it better be a state we know about
          if !@states[to]
            raise(SyntaxError, "Bogus transition: #{state} #{on} #{to}")
          end
        end
        
        if on =~ /^\$(.*)$/
          if $1 == 'NameStart'
            @char_classes[@states[state]] = :namestart_char
          elsif $1 == 'NameC'
            @char_classes[@states[state]] = :name_char
          end
          @class_transitions[state] << $1
          RX::CharClass.bytes($1).each_byte do |b|
            transition(state, b, to, actions) 
          end
        else
          on.each_byte { |b| transition(state, b, to, actions) }
        end
      end
    end
    @machine.each_index do |i|
      unless @machine[i]
        raise(NameError, "nil at #{i}")
      end
    end
    STDERR.puts "#{@states.size} states, " +
      "#{@machine_size * 2} bytes, " +
      "#{@action_list.size} actions."
    @out_dir += '/' if (@out_dir != '')
    File.open("#{@out_dir}machine", 'w') { |m| m.write(@machine.pack('C*')) }
    File.open("#{@out_dir}actions", 'w') { |a| a.write(@actions.pack('C*')) }
    File.open("#{@out_dir}support.rb", 'w') do |support|
      support.puts "# Generated by machine_builder.rb; Don't edit!"
      support.print "module RX\n\n"

      support.puts "  class Reader"

      write_fallbacks support
      write_error_messages support
      name_classes support
      write_actions support
      write_state_class_transitions support
        
      support.print "  end\n\n"

      make_char_classes @out_dir, support
      
      support.puts "end"
    end
    nil
  end

  def write_state_class_transitions(support)
    support.print "    NAME_CLASS_TRANSITIONS = [\n      "
    on_line = 0
    @char_classes.each do |cc|
      support.print ":#{cc}, "
      on_line += 1
      if on_line == 4
        support.print "\n      "
        on_line = 0
      end     
    end
    support.print "\n    ]\n"
  end

  def write_actions(support)
    1.upto(@action_list.length - 1) do |i|
      support.puts "    def action_#{i}(c)"
      support.puts "      result = false"
      @action_list[i].split.each do |a|
        a = a.strip.gsub(/^!/, '')
        if a =~ /^(.*)\((.*)\)/
          op = $1
          if op == 'CharRef'
            args = $2.unpack('U*')[0] # works in both 1.8 & 1.9
          else
            args = $2.split(/,/).map do |arg|
              if arg =~ /^\d*$/
                arg
              else
                arg.gsub!(/\"/, '\"')
                "\"#{arg}\""
              end
            end
            args = args.join(', ')
          end
          a = "#{op}(c, #{args})"
        else
          a = "#{a}(c)"
        end
        support.puts "      result ||= a_#{a}"
      end
      support.puts "      result"
      support.puts "    end"
    end

    support.puts "\n    ACTION_DISPATCHER = ["
    support.puts "      nil,"
    1.upto(@action_list.length - 1) do |i|
      support.puts "      :action_#{i},"
    end
    support.puts "    ]"

    support.puts "    def do_action(i, c)"
    support.puts "      send ACTION_DISPATCHER[i], c"
    support.print "    end\n\n"

  end

  def write_fallbacks(support)
    support.print "    FALLBACKS = {\n      "
    on_line = 0
    @states_in_order.each do |state|
      support.print "#{@states[state]} => #{@states[@fallbacks[state]]}, "
      on_line += 1
      if on_line == 6
        support.print "\n      "
        on_line = 0
      end
    end
    support.print "\n    }\n\n"
  end

  def write_error_messages(support)
    support.print "    ERROR_MESSAGES = {\n      "
    on_line = 0
    @states_in_order.each do |state|
      msg = @error_messages[state]
      next unless msg.length > 0
      msg.gsub!(/\"/, '\"')
      support.print "#{@states[state]} => \"#{@error_messages[state]}\", "
      on_line += msg.length
      if on_line > 20
        support.print "\n      "
        on_line = 0
      end
    end
    support.print "\n    }\n\n"
  end

  def name_classes(support)
    support.print "    STATE_INDOC = #{@states['InDoc']}\n\n"
    on_line = 0
    support.print "    STATE_NAMES = {\n        "
    lookup = @states.invert
    lookup.keys.sort.each do |num|
      support.print "#{num} => :#{lookup[num]}, "
      on_line += lookup[num].length
      if on_line > 20
        support.print "\n        "
        on_line = 0
      end
    end
    support.print "\n    }\n\n"
  end

  def transition(from, byte, to, actions)
    if to =~ /^(.*)\((.*)\)/
      op = $1
      args = $2

      # magic goes here
      case $1
      when 'Pop'
        actions = (actions) ? "Pop #{actions}" : "Pop"
        transition(from, byte, from, actions)
        
      when 'Push'
        pushto, popto = args.split(/,\s*/)
        popto = @states[popto]
        unless popto
          raise(SyntaxError,
                "Bogus transition: #{from} #{byte} #{to} #{actions}")
        end
        action = "Push(#{popto})"
        actions = (actions) ? "#{action} #{actions}" : action
        transition(from, byte, pushto, actions)

      when 'Keyword'
        # e.g.: T U Keyword(PUBLIC,AfterPublicKW,2)
        kw, popto, offset = args.split(/,\s*/)
        popto = @states[popto]
        unless popto
          raise(SyntaxError,
                "Bogus transition: #{from} #{byte} #{to} #{actions}")
        end
        action = "KW(#{kw},#{popto},#{offset})"
        actions = (actions) ? "#{action}, #{actions}" : action
        transition(from, byte, 'Keyword', actions)

      else
        raise(ArgumentError, "Bogus to-function: #{to}")
      end
    else
      index = (@states[from] * 128) + byte
      if index > @machine_size
        puts "GACK: states[from] = #{@states[from]}"
        raise(SyntaxError,
              "Machine grew on trans: #{from} #{byte} #{to} #{actions}")
      end
      unless @states[to]
        raise(SyntaxError,
              "Bogus transition: #{from} #{byte} #{to} #{actions}")
      end

      # don't record if it's already set, order matters
      if (@machine[index] == 0)
        @machine[index] = @states[to]
      
        if actions && (@actions[index] == 0)
          @action_list << actions unless @action_list.index(actions)
          @actions[index] = @action_list.index(actions)
        end
      end
    end
  end

end

MachineBuilder.build(ARGV[0] || 'autom', ARGV[1] || '.')
